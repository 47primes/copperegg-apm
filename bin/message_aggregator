#!/usr/bin/env ruby

require "socket"
require "json"
require "logger"
require "sqlite3"

class EventAggregator
  PORT = 28344
  HOST = "127.0.0.1".freeze

  def self.udp_socket
    return @udp_socket if @udp_socket
    @udp_socket = UDPSocket.new
    @udp_socket.bind(HOST, PORT)
    @udp_socket
  end

  def self.db
    return @db if @db
    @db = SQLite3::Database.new "copperegg-apm.db"
    create_messages
    create_message_counts
    @db
  end

  def self.create_messages
    @db.execute <<-SQL
      CREATE TABLE IF NOT EXISTS messages (
        id integer primary key
        stacktrace text
        type varchar(255)
        value text
      )
    SQL
  end

  def self.create_message_counts
    @db.execute <<-SQL
      CREATE TABLE IF NOT EXISTS message_counts (
        id integer primary key
        time real
        foreign key(message_id) references messages(id)
      )
    SQL
  end

  def self.insert_message(params)
    unless exist?(message)
      sql = <<-SQL
      INSERT INTO messages (type, stacktrace, value)
      VALUES (?, ?, ?)
      SQL
      db.execute sql, params[:type], params[:stacktrace], params[:value]
    end
    insert_message_count(params)
  end

  def self.insert_message_count(params)
    sql = <<-SQL
      INSERT INTO message_counts (message_id, time)
      VALUES (?, ?)
    SQL
    db.execute sql, params[:message_id], params[:time]
  end

  def self.exist?(params)
    if type == :sql
      sql = "SELECT COUNT(id) FROM messages WHERE type = ? AND stacktrace = ?"
      db.execute sql, params[:type], params[:stacktrace]
    else
      sql = "SELECT COUNT(id) FROM messages WHERE type = ? AND stacktrace = ? AND value = ?"
      db.execute sql, params[:type], params[:stacktrace], params[:value]
    end
  end

  def self.run
    fork do
      payload, host = udp_socket.recvfrom(PORT)
      payload = payload.split("\x00")
      payload = payload.select { |i| i.size > 2 }
      payload = payload.map { |i| i.sub(/^[^\{]+/, "") }.join("\n")

      params = JSON(payload)
      insert_message(params)
    end
    Process.waitall
  end
end
